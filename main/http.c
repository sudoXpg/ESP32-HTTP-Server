#include "http.h"

// to access EMBED_FILES
// symbols generated by compiler
extern const uint8_t _binary_webpage_html_start[] asm("_binary_webpage_html_start");
extern const uint8_t _binary_webpage_html_end[]   asm("_binary_webpage_html_end");


const char *not_found_response =
                "HTTP/1.1 404 Not Found\r\n"
                "Content-Type: text/html\r\n"
                "Content-Length: 56\r\n"
                "\r\n"
                "<html><body><h1>404 Not Found</h1></body></html>";



void handle_http(int client_fd){
    char buffer[1024];
    char response_header[512];


    // read HTTP request
    int bytes_rec = recv(client_fd, buffer, sizeof(buffer)-1, 0);
    
    if (bytes_rec <= 0) {
        printf("HTTP_SERVER recv error or connection closed\n");
        close(client_fd);
        return;
    }

    if(bytes_rec>0){
        buffer[bytes_rec]='\0';
        printf("HTTP_SERVER request :%s\n",buffer);
    }

    
    // Access the embedded HTML file
    const uint8_t *response_body = _binary_webpage_html_start;
    size_t file_size = _binary_webpage_html_end - _binary_webpage_html_start;


    // Prepare HTTP response header
    snprintf(response_header, sizeof(response_header),
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/html\r\n"
            "Content-Length: %zu\r\n"
            "\r\n",
            file_size);


    // send HTTP response
    if (send(client_fd, response_header, strlen(response_header), 0) < 0) {
        printf("Failed to send HTTP header\n");
        close(client_fd);
        return;
    }
    if (send(client_fd, response_body, file_size, 0) < 0) {
        printf("Failed to send HTTP body\n");
        close(client_fd);
        return;
    }


    
    vTaskDelay(pdMS_TO_TICKS(10));


}


void http_server() {
    int sockfd, new_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addr_size;
    char client_ip[INET_ADDRSTRLEN];


    // Set up TCP socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        printf("HTTP_SERVER Unable to create socket");
        return;
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind socket to the address
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf("HTTP_SERVER Unable to bind socket");
        return;
    }

    // Listen for incoming connections
    if (listen(sockfd, BACKLOGS) < 0) {
        printf("HTTP_SERVER Listen failed");
        return;
    }

    printf("HTTP_SERVER Server listening on port %d\n", PORT);

    while (1) {
        addr_size = sizeof(client_addr);
        new_fd = accept(sockfd, (struct sockaddr *)&client_addr, &addr_size);
        if (new_fd < 0) {
            printf("HTTP_SERVER Unable to accept connection");
            continue;
        }

        // Convert IP address to string
        inet_ntoa_r(client_addr.sin_addr, client_ip, sizeof(client_ip));
        printf("HTTP_SERVER Client connected: %s", client_ip);

        handle_http(new_fd);

        // Close connection
        close(new_fd);

        // Yield control to avoid WDT triggering
        vTaskDelay(pdMS_TO_TICKS(10)); // Delay 10ms
    }

    // Cleanup
    close(sockfd);
}

